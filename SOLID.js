// S: Single Responsibility Principle 
    // Компонент програмного забезпечення повинен  відповідати лише за щось одне. Якщо компонент відповідає за вирішення декількох завдань, його підсистеми, що реалізують рішення цих задач, виявляються пов'язаними один з одним. Зміни в одній такій підсистемі ведуть до змін в іншій.

// O: Open-Closed Principle 
    // Відкритість для розширення і закритість для змін 

// L: Liskov Substitution Principle 
    // Необхідно, щоб підкласи могли б служити заміною для своїх суперкласів.
    // Мета цього принципу полягає в тому, щоб класи-спадкоємці могли б використовуватися замість батьківських класів, від яких вони утворені, не порушуючи роботу програми. Якщо виявляється, що в коді перевіряється тип класу, значить принцип підстановки порушується.

// I: Interface Segregation Principle 
    // Багато спеціалізованих інтерфейсів краще за один загальний
    // Створюйте вузькоспеціалізовані інтерфейси, призначені для конкретного клієнта. Клієнти не повинні залежати від інтерфейсів, які вони не використовують.
    // Цей принцип спрямований на усунення недоліків, пов'язаних з реалізацією великих інтерфейсів.

// D: Dependency Inversion Principle 
    // Об'єктом залежності повинна бути абстракція, а не щось конкретне.
    // Модулі верхніх рівнів не повинні залежати від модулів нижніх рівнів. Обидва типи модулів повинні залежати від абстракцій.
    // Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.
    // В процесі розробки програмного забезпечення існує момент, коли функціонал додатка перестає поміщатися в рамках одного модуля. Коли це відбувається, нам доводиться вирішувати проблему залежностей модулів. В результаті, наприклад, може виявитися так, що високорівневі компоненти залежать від низькорівневих компонентів.