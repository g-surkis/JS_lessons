// GRASP (General Responsibility Assignment Software Patterns) - шаблони проектування, що використовуються для вирішення спільних завдань за призначенням обов'язків класів і об'єктів.

// GRAPS патерни не мають вираженої структури, чіткої області застосування і конкретної розв'язуваної проблеми, а лише представляють собою узагальнені підходи / рекомендації / принципи, які використовуються при проектуванні дизайну системи.

// Information Expert
    // Відповідальність повинна бути призначена тому, хто володіє максимумом необхідної інформації для виконання - інформаційного експерту.

// Creator
    // суть відповідальності такого об'єкта в тому, що він створює інші об'єкти
    // Патерн Creator вирішує, хто повинен створювати об'єкт. Фактично, це застосування шаблону Information Expert до проблеми створення об'єктів. Більш конкретно, потрібно призначити класу B обов'язок створювати екземпляри класу A, якщо виконується якомога більше з наступних умов:

    // Клас B містить (contains) або агрегує (aggregate) об'єкти A.
    // Клас B записує (records) екземпляри об'єктів A.
    // Клас B активно використовує (closely uses) об'єкти A
    // Клас B володіє даними ініціалізації (has the initializing data) для об'єктів A.
    // Альтернативою паттерну є Фабрика. В цьому випадку створення об'єктів концентрується в окремому класі.

// Controller
    // Контролер бере на себе відповідальність за виконання операцій, що приходять від користувача і часто виконує сценарій одного або декількох варіантів використання (наприклад, один контролер може обробляти сценарії створення і видалення користувача). Як правило, контролер не виконує роботу самостійно, а делегує обов'язки компетентним об'єктів.

    // Іноді клас-контролер всю систему в цілому, кореневої об'єкт, пристрій або важливу підсистему (зовнішній контролер).

// Low Coupling
    // Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах.
    // Коли ми йдемо від конкретних реалізацій і абстрагуємося на рівнях інтерфейсів (які легко підміняти потрібними нам реалізаціями), тоді код не зав'язаний на певні реалізації.

// High Cohesion
    // По суті High Cohesion дуже тісно пов'язана з Single Responsibility Principle (SRP) з SOLID принципів. High Cohesion виходить в результаті дотримання SRP.

    // High Cohesion принцип говорить про те, що клас повинен намагатися виконувати якомога менше не специфічних для нього завдань, і мати цілком певну область застосування.

// Pure Fabrication
    // Існує поняття моделі програмування предметної області, згідно з якою, кожної суті з предметної області відповідає один або більше класів програмного середовища. При цьому, обов'язки взаємодії сутностей, як правило накладаються на них самих. Такий підхід має очевидний недолік - висока зв'язність модулів системи. Шаблон Pure Fabrication дозволяє вирішити дану проблему, шляхом введення в програмне середовище додаткового класу (що не відображає реальної суті з предметної області) і наділення його необхідними обов'язками.

// Indirection (Посередник)
    // Шаблон Indirection реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.

// Polymorphism
// 1: Поліморфізм дозволяє реалізовувати однойменні публічні методи, дозволяючи різним класам виконувати різні дії при одному і тому ж виклику.

    // 2: Шаблон поліморфізм дозволяє обробляти альтернативні варіанти поведінки на основі типу. При цьому, альтернативні реалізації наводяться до узагальненого інтерфейсу.

    // Принцип поліморфізму є основоположним в ООП. У цьому контексті принцип тісно пов'язаний з GoF патерном strategy. Це найяскравіший приклад реалізації поліморфізму.

// Protected Variations (Стійкість до змін)
    //  Protected Variations захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс. Все взвімодействіе між елементами має відбуватися через нього. Поведінка може варіюватися лише за допомогою створення іншої реалізації інтерфейсу.

    // Проблема модифікації системи найбільш актуальна в умовах коли вимоги динамічно змінюються. Найчастіше, вдається виділити т.зв. точки нестійкості системи, які найбільш часто будуть схильні до зміни / модифікації. Тоді, сутність шаблону Protected Variations полягає в усуненні точок нестійкості, шляхом визначення їх в якості інтерфейсів і реалізації для них різних варіантів поведінки.